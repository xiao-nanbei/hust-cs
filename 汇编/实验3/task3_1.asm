.686P
.MODEL FLAT,STDCALL
ExitProcess PROTO STDCALL:DWORD
Sleep proto stdcall :dword
INCLUDELIB KERNEL32.LIB
printf PROTO C:VARARG
scanf PROTO C: DWORD,:VARARG
INCLUDELIB LIBCMT.LIB
INCLUDELIB LEGACY_STDIO_DEFINITIONS.LIB
FLAG_TO_0 macro v1
	PUSH EAX
	MOV	EAX,0
	MOV v1,EAX
	POP	EAX
	endm
FLAG_TO_1 macro v1
	PUSH EAX
	MOV	EAX,1
	MOV	v1,EAX
	POP EAX
	endm

.DATA
lpFmt1	DB	"%s",0ah,0dh,0
lpFmt2	DB	"%s",0
lpFmt3	DB  "%d",0
lpFmt4	DB	"%hd",0ah,0dh,0
lpFmt   DB	"%d seconds",0ah, 0dh, 0
freq_l  dword  0
freq_h  dword  0
BNAME   DB	'TANXUAN',3 DUP(0) 
BPASS   DB	'U201915033',0
GOODS  STRUCT
GOODSNAME  DB 10 DUP(0)
BUYPRICE   DW  0
SELLPRICE  DW  0
BUYNUM     DW  0
SELLNUM    DW  0
RATE       DW  0
GOODS  ENDS
GA1	GOODS <'PEN',15, 20, 70, 25, ?>
GA2	GOODS <'PENCIL',2, 3, 100, 50, ?>
GA3	GOODS <'BOOK',30, 40, 25, 5, ?>
GA4	GOODS <'RULER',3, 4, 200, 150, ?>
GA5	GOODS <'MAX',0,0,0,0,255>
OP DD ?
SOLD_NUM	DW	?
SUPPLE_NUM	DW	?
USER_LOG	DB	'Please enter your username:',0
PASSWORD_LOG	DB	'Please enter your password:',0
LOGIN_FAIL	DB	'wrong username or password',0
TABLE_MENU	DB	'Please enter number1-5 to choose function'
					DB 0AH,0DH,'1:Find products'
					DB 0AH,0DH,'2:Shipment'
					DB 0AH,0DH,'3:replenishment'
					DB 0AH,0DH,'4:Calculate the profit margin of goods'
					DB 0AH,0DH,'5:Sort'
					DB 0AH,0DH,'6:Clock'
					DB 0AH,0DH,'7:Exit',0
CHOOSE_FAIL	DB	'wrong number',0
FIND_ITEM	DB	'Please enter the item name:',0
FIND_FAIL	DB	'Fail to find',0
SOLD_ITEM	DB	'Please input the quantity you want to sell',0
NOT_ENOUGH	DB	'It is not enough',0
SUPPLE_ITEM	DB	'Please input how many goods you want to replenish',0
EXIT_END	DB	'Sign out',0
IN_NAME		DB	10 DUP(0)
IN_PWD		DB	10 DUP(0)
IN_ITEM		DB	10 DUP(0)
I_NUM		DD	0
MAX_NUM		DW	0
MIN_NUM		DW	0
TEMP		DD	0
J_NUM		DD	0
FLAG_SOLD	DD	0
FLAG_EQULES DD	1
.STACK 200
.CODE
EQULES_FUN proc
	ADD ESI,EBX
	MOV ECX,0AH
	REPE CMPSB
	JZ EQULES_FUN_EXIT
	SET_FLAG:
		FLAG_TO_0 FLAG_EQULES
	EQULES_FUN_EXIT:
		ret
EQULES_FUN endp
FIND_FUN proc
	INVOKE printf,OFFSET lpFmt1,OFFSET FIND_ITEM
	INVOKE scanf,OFFSET lpFmt2,OFFSET IN_ITEM
	MOV EBX,0
	MOV EAX,4
	MOV	I_NUM,EAX
	FLAG_TO_1 FLAG_EQULES
	PWORK:
		LEA ESI,GA1
		LEA	EDI,IN_ITEM
		CALL EQULES_FUN
		CMP FLAG_EQULES,1
		JZ	OUT_PUT
		MOV	EAX,1
		MOV	FLAG_EQULES,EAX
		ADD EBX,20
		DEC I_NUM
		JNZ PWORK
	INVOKE printf,OFFSET lpFmt1,OFFSET FIND_FAIL
	JMP	FIND_FUN_EXIT
	OUT_PUT:
		INVOKE printf,OFFSET lpFmt1,OFFSET IN_ITEM
		INVOKE printf,OFFSET lpFmt4,GA1[EBX][10]
		INVOKE printf,OFFSET lpFmt4,GA1[EBX][12]
		INVOKE printf,OFFSET lpFmt4,GA1[EBX][14]
		INVOKE printf,OFFSET lpFmt4,GA1[EBX][16]
		INVOKE printf,OFFSET lpFmt4,WORD PTR GA1[EBX][18]
	FIND_FUN_EXIT:
		ret
FIND_FUN endp
SOLD_FUN proc
SOLD:
	INVOKE printf,OFFSET lpFmt1,OFFSET FIND_ITEM
	INVOKE scanf,OFFSET lpFmt2,OFFSET IN_ITEM
	INVOKE printf,OFFSET lpFmt1,OFFSET SOLD_ITEM
	INVOKE scanf,OFFSET lpFmt3,OFFSET SOLD_NUM
	MOV EBX,0
	MOV EAX,4
	MOV	I_NUM,EAX
	FLAG_TO_1 FLAG_EQULES
	SOLD_PWORK:
		LEA ESI,GA1
		LEA	EDI,IN_ITEM
		CALL EQULES_FUN
		CMP FLAG_EQULES,1
		JZ	OUT_SOLD
		MOV	EAX,1
		MOV	FLAG_EQULES,EAX
		ADD EBX,20
		DEC I_NUM
		JNZ SOLD_PWORK
	INVOKE printf,OFFSET lpFmt1,OFFSET FIND_FAIL
	JMP	SOLD_FUN_EXIT
	OUT_SOLD:
		MOV AX,WORD PTR GA1[EBX][14]
		MOV CX,WORD PTR GA1[EBX+16]
		CMP AX,SOLD_NUM
		JB	NOT_EN
		SUB AX,SOLD_NUM
		CMP AX,CX
		JB	NOT_EN
		ADD CX,SOLD_NUM
		MOV WORD PTR GA1[EBX+16],CX
		JMP SOLD_FUN_EXIT
		NOT_EN:
		INVOKE printf,OFFSET lpFmt1,OFFSET NOT_ENOUGH
	SOLD_FUN_EXIT:
		ret
SOLD_FUN endp
SUPPLE_FUN	proc
	INVOKE printf,OFFSET lpFmt1,OFFSET FIND_ITEM
	INVOKE scanf,OFFSET lpFmt2,ADDR[IN_ITEM]
	INVOKE printf,OFFSET lpFmt1,OFFSET SUPPLE_ITEM
	INVOKE scanf,OFFSET lpFmt3,OFFSET SUPPLE_NUM
	MOV EBX,0
	MOV EAX,4
	MOV	I_NUM,EAX
	FLAG_TO_1 FLAG_EQULES
	SUPPLE_PWORK:
		LEA ESI,GA1
		LEA	EDI,IN_ITEM
		CALL EQULES_FUN
		CMP FLAG_EQULES,1
		JZ	OUT_SUPPLE
		MOV	EAX,1
		MOV	FLAG_EQULES,EAX
		ADD EBX,20
		DEC I_NUM
		JNZ	SUPPLE_PWORK
	INVOKE printf,OFFSET lpFmt1,OFFSET FIND_FAIL
	JMP	SUPPLE_FUN_EXIT
	OUT_SUPPLE:
		MOV AX,WORD PTR GA1[EBX][14]
		ADD AX,SUPPLE_NUM
		MOV WORD PTR GA1[EBX+14],AX
	SUPPLE_FUN_EXIT:
		ret
SUPPLE_FUN endp 
CLU_FUN	proc
	MOV ESI,0
	MOV EDI,4
	CLU_PWORK_FUN:
		MOV EAX,0
		MOV EBX,0
		MOV AX,WORD PTR GA1[ESI+12]
		IMUL AX,WORD PTR GA1[ESI+16]
		MOV BX,WORD PTR GA1[ESI+10]
		IMUL BX,WORD PTR GA1[ESI+14]
		SUB AX,BX
		MOVSX EAX,AX
		MOVSX EBX,BX
		IMUL EAX,100
		CDQ
		IDIV EBX
		MOV WORD PTR[GA1+ESI+18],AX
		INVOKE printf,OFFSET lpFmt4,WORD PTR GA1[ESI+18]
		ADD ESI,20
		DEC EDI
		JNZ CLU_PWORK_FUN
	CLU_FUN_EXIT:
		ret
CLU_FUN endp
SORT_FUN proc 
	MOV EDI,4
	MOV CX,WORD PTR GA5[18]
	MOV	I_NUM,EDI
	SORT_PWORK_1_FUN:
		MOV EDI,0
		MOV	FLAG_SOLD,0
		MOV ESI,4
		MOV J_NUM,ESI
		MOV	ESI,0
		MOV EAX,0
		MOV EBX,0
		MOV DX,WORD PTR GA1[ESI+18]
		MOV MAX_NUM,DX
		SORT_PWORK_2_FUN:
			MOV DX,WORD PTR GA1[ESI+18]
			CMP DX,MAX_NUM
			JGE	OUT_SORT_FUN
			GET_FUN:
			ADD	ESI,20
			DEC J_NUM
			JNZ	SORT_PWORK_2_FUN
			CMP FLAG_SOLD,0
			JE SOLD_END_FUN
			MOV EBX,OFFSET GA1
			ADD	EBX,EDI
			INVOKE printf,OFFSET lpFmt1,EBX
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][10]
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][12]
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][14]
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][16]
			INVOKE printf,OFFSET lpFmt4,WORD PTR GA1[EDI][18]
			MOV CX,MAX_NUM
		DEC I_NUM
		JNZ	SORT_PWORK_1_FUN
	OUT_SORT_FUN:
		CMP	DX,CX
		JGE	OUT_SORT_2_FUN
		MOV	MAX_NUM,DX
		MOV	EDI,ESI
		ADD FLAG_SOLD,1
		OUT_SORT_2_FUN:
			JMP GET_FUN
	SOLD_END_FUN:
		MOV EAX,4
		MOV J_NUM,EAX
		MOV	ESI,0
		MOV DX,WORD PTR GA1[ESI+18]
		MOV MIN_NUM,DX
		SOLD_END_PWOEK_FUN:
			MOV DX,WORD PTR GA1[ESI+18]
			CMP DX,MIN_NUM
			JL	OUT_SOLD_END_FUN
			GET_END_FUN:
			ADD ESI,20
			DEC J_NUM
			JNZ	SOLD_END_PWOEK_FUN
			MOV EBX,OFFSET GA1
			ADD	EBX,EDI
			INVOKE printf,OFFSET lpFmt1,EBX
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][10]
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][12]
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][14]
			INVOKE printf,OFFSET lpFmt4,GA1[EDI][16]
			INVOKE printf,OFFSET lpFmt4,WORD PTR GA1[EDI][18]
		JMP	SORT_FUN_EXIT
		OUT_SOLD_END_FUN:
			MOV MIN_NUM,DX
			MOV EDI,ESI
			JMP	GET_END_FUN
	SORT_FUN_EXIT:
		ret
SORT_FUN endp

main proc c
LOGNAME:
	INVOKE printf,OFFSET lpFmt1 ,OFFSET USER_LOG
	INVOKE scanf,OFFSET lpFmt2 ,OFFSET IN_NAME
LOG1:
	LEA ESI,BNAME
	LEA EDI,IN_NAME
	MOV	EBX,0
	CALL EQULES_FUN
	CMP FLAG_EQULES,1
	JZ	LOGPWD
	INVOKE printf,OFFSET lpFmt1,OFFSET LOGIN_FAIL
	MOV EAX,1
	MOV FLAG_EQULES,EAX
	JMP LOGNAME
LOGPWD:
	INVOKE printf,OFFSET lpFmt1,OFFSET PASSWORD_LOG
	INVOKE scanf,OFFSET lpFmt2,OFFSET IN_PWD
LOG2:
	LEA ESI,BPASS
	LEA EDI,IN_PWD
	MOV	EBX,0
	CALL EQULES_FUN
	CMP FLAG_EQULES,1
	JZ  MENU
	INVOKE printf,OFFSET lpFmt1,OFFSET LOGIN_FAIL
	MOV EAX,1
	MOV FLAG_EQULES,EAX
	JMP LOGPWD
MENU:
	INVOKE printf,OFFSET lpFmt1,OFFSET TABLE_MENU
	INVOKE scanf,OFFSET lpFmt3,OFFSET OP
	CMP op,1
	JE FIND
 	CMP op,2
	JE SOLD
	CMP op,3
	JE SUPPLE
	CMP op,4
	JE CLU
	CMP op,7
	JE EXIT
	CMP op,5
	JE SORT
	CMP op,6
	JE	CLO
	INVOKE printf,OFFSET lpFmt1,OFFSET CHOOSE_FAIL
	JMP MENU
FIND:
	CALL FIND_FUN
	JMP MENU
SOLD:
	CALL SOLD_FUN
	JMP	MENU
SUPPLE:
	CALL SUPPLE_FUN
	JMP MENU
CLU:
	CALL CLU_FUN
	JMP MENU
SORT:
	CALL SORT_FUN
	JMP MENU
CLO:
	rdtsc
    sub eax, ecx
    sbb edx, ebx  
    mov freq_l, eax
    mov freq_h, edx 
    rdtsc         
	mov ecx, eax
	mov ebx, edx
	push ecx
	push ebx
    mov ecx,1000
L1:
    PUSH ecx
    call  CLU_FUN
    call  SORT_FUN
    pop ecx
    dec ecx 
    jnz L1

	rdtsc
	pop ebx
	pop ecx
	sub eax, ecx
	sbb edx, ebx  
	div freq_l
	invoke printf, offset lpFmt, eax
jmp  MENU
EXIT:
	INVOKE printf,OFFSET lpFmt1,OFFSET EXIT_END
	INVOKE ExitProcess,0
main endp
END
